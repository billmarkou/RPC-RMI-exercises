/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

#include "ask.h"
 

void ask_prog_1(char *host, int sock, int processNum, int arrL, int *numbers, int multiplier)
{
	CLIENT *clnt;
	inputsMo *result_1;
	inputsMo mo_1_arg;
	inputsMinMax *result_2;
	inputsMinMax minmax_1_arg;
	inputsMul *result_3;
	inputsMul mul_1_arg; 
	char res_buffer[256];
	int n;

#ifndef DEBUG
	clnt = clnt_create(host, ask_PROG, ask_VERS, "udp");
	if (clnt == NULL)
	{
		clnt_pcreateerror(host);
		exit(1);
	}
#endif /* DEBUG */

	//============================================================

	// printf("check variables are passed to ask1 prog correctly\n");
	// printf("process number is = %d\n", processNum);
	// printf("arrL is = %d\n", arrL);
	// for (int i = 0; i < arrL; i++)
	// {
	// 	printf("number %d is = %d\n", i, numbers[i]);
	// }
	// if (processNum == 3)
	// {
	// 	printf("multiplier is = %d\n", multiplier);
	// }

	// printf("===============================================================\n");

	//============================================================

	if (processNum == 1)
	{ 
		mo_1_arg.b.b_len = arrL;
		mo_1_arg.b.b_val = (int *)malloc(arrL * sizeof(int));
		for (int i = 0; i < arrL; i++)
		{
			mo_1_arg.b.b_val[i] = numbers[i];
		}
		result_1 = mo_1(&mo_1_arg, clnt);
		if (result_1 == (inputsMo *)NULL)
		{
			clnt_perror(clnt, "call failed"); 
		}
		else
		{

			bzero(res_buffer, 256); 
			*res_buffer = result_1->resultMo;



			n = write(sock, res_buffer, 256); 
			// printf("##########################\n");
			// printf(" #### M.O. is : %d ####\n", result_1->resultMo);
			// printf("##########################\n");   
		}
	}
	else if (processNum == 2)
	{
		minmax_1_arg.b.b_len = arrL;
		minmax_1_arg.b.b_val = (int *)malloc(arrL * sizeof(int));
		minmax_1_arg.minMax.minMax_len = 2;
		minmax_1_arg.minMax.minMax_val = (int *)malloc(2 * sizeof(int));
		for (int i = 0; i < arrL; i++)
		{
			minmax_1_arg.b.b_val[i] = numbers[i];
		}
		result_2 = minmax_1(&minmax_1_arg, clnt);
		if (result_2 == (inputsMinMax *)NULL)
		{
			clnt_perror(clnt, "call failed"); 
		}
		else
		{ 
			bzero(res_buffer, 256);

			*res_buffer  = result_2->minMax.minMax_val[0];
			*(res_buffer + sizeof(int)) = result_2->minMax.minMax_val[1];
	
			n = write(sock, res_buffer, 256);
			// printf("##########################\n");
			// printf(" #### min value is : %d ####\n", result_2->minMax.minMax_val[0]);
			// printf("##########################\n");
			// printf(" #### max value is : %d ####\n ", result_2->minMax.minMax_val[1]);
			// printf("##########################\n");  
 
		}
	}
	else if (processNum == 3)
	{
		mul_1_arg.b.b_len = arrL;
		mul_1_arg.mulArr.mulArr_len = arrL;
		mul_1_arg.b.b_val = (int *)malloc(arrL * sizeof(int));
		mul_1_arg.mulArr.mulArr_val = (int *)malloc(arrL * sizeof(int));
		mul_1_arg.mult = multiplier;
		for (int i = 0; i < arrL; i++)
		{
			mul_1_arg.b.b_val[i] = numbers[i];
		}
		result_3 = mul_1(&mul_1_arg, clnt);
		if (result_3 == (inputsMul *)NULL)
		{
			clnt_perror(clnt, "call failed"); 
		}
		else
		{

			bzero(res_buffer, 256);
			int arrLen = result_3->mulArr.mulArr_len;

			char* cursor = res_buffer;
			*cursor = arrLen;
			

			for (int i = 0; i<arrLen; i++) 
			{
				cursor += sizeof(int);
				*cursor = result_3->mulArr.mulArr_val[i];
			}
	
			n = write(sock, res_buffer, 256);
			// printf("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n");
			// printf("xxxx resulted array's lenght : %d xxxx\n", result_3->mulArr.mulArr_len);
			// printf("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n");
			// printf("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n");
			// for (int i=0; i<arrL; i++)
			// {
			// 	printf("##########################\n");
			// 	printf("multiplied number %d is : %d\n",i ,result_3->mulArr.mulArr_val[i]);
			// }
			// printf("##########################\n");

			  
		}
	} 
	/*	result_1 = mo_1(&mo_1_arg, clnt);
	if (result_1 == (inputsMo *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	result_2 = minmax_1(&minmax_1_arg, clnt);
	if (result_2 == (inputsMinMax *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	result_3 = mul_1(&mul_1_arg, clnt);
	if (result_3 == (inputsMul *) NULL) {
		clnt_perror (clnt, "call failed");
	}
*/
#ifndef DEBUG
	clnt_destroy(clnt);
#endif /* DEBUG */
 
}

void error(char *msg)
{
	perror(msg);
	exit(1);
}
/******** DOSTUFF() *********************
 There is a separate instance of this function 
 for each connection.  It handles all communication
 once a connnection has been established.
 *****************************************/
void sock_dostuff(int sock, char* rpc_host)
{
	int n, numOfProccess;
	char buffer[256];

	bzero(buffer, 256);

	n = read(sock, buffer, 255);

	if (n < 0)
		error("ERROR reading from socket");

	char *cursor = buffer;

	int processNumber = cursor[0];
	cursor += sizeof(int);

	int multiplier = cursor[0];
	cursor += sizeof(int);

	int len = cursor[0]; 

	int *numbers = (int *)malloc(sizeof(int) * len);

	for (int i = 0; i < len; i++)
	{
		cursor += sizeof(int);
		numbers[i] = cursor[0]; 
	}

	 

	
	if (processNumber == 1)
	{
		ask_prog_1(rpc_host, sock, processNumber, len, numbers, multiplier); 
	}
	else if (processNumber == 2)
	{
		ask_prog_1(rpc_host, sock, processNumber, len, numbers, multiplier); 
	}
	else if (processNumber == 3)
	{
		ask_prog_1(rpc_host, sock, processNumber, len, numbers, multiplier); 
	}

	// n = write(sock, "I got your message", 18);

	bzero(buffer, 256); 

	if (n < 0)
		error("ERROR writing to socket");
}

int main(int argc, char *argv[])
{

	// int multiplier = 0;
	// if (argc < 2) {
	// 	printf ("usage: %s server_host\n", argv[0]);
	// 	exit (1);
	// }
	
	// int processNum = atoi(argv[2]);
	// int arrL = atoi(argv[3]);
	// int *numbers = (int*)malloc(arrL*sizeof(int));
	// for (int i=0; i<arrL; i++)
	// {
	// 	numbers[i] = atoi(argv[i+4]);
	// }
	// if (processNum == 3)
	// {
	// 	multiplier = atoi(argv[4+arrL]);
	// }

	// //============================================================

	// printf ("****************************************************************\n");
	// printf ("check variables are initialized correctly\n");
	// printf ("process number is = %d\n", processNum);
	// printf ("arrL is = %d\n", arrL);
	// for (int i=0; i<arrL; i++)
	// {
	// 	printf ("number %d is = %d\n", i, numbers[i]);
	// }
	// if (processNum == 3)
	// {
	// 	printf ("multiplier is = %d\n", multiplier);
	// }

	// printf ("===============================================================\n");

	// //============================================================

	int sockfd, newsockfd, portno, clilen, pid;
	struct sockaddr_in serv_addr, cli_addr;
	char* rpc_host = argv[2];
	if (argc < 2)
	{
		fprintf(stderr, "ERROR, no port provided\n");
		exit(1);
	}
	sockfd = socket(AF_INET, SOCK_STREAM, 0);
	if (sockfd < 0)
		error("ERROR opening socket");
	bzero((char *)&serv_addr, sizeof(serv_addr));
	portno = atoi(argv[1]);
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = INADDR_ANY;
	serv_addr.sin_port = htons(portno);
	if (bind(sockfd, (struct sockaddr *)&serv_addr,
			 sizeof(serv_addr)) < 0)
		error("ERROR on binding");
	listen(sockfd, 5);
	clilen = sizeof(cli_addr);

	// rpcHost = argv[2];

	while (1)
	{
		newsockfd = accept(sockfd,
						   (struct sockaddr *)&cli_addr, &clilen);
		if (newsockfd < 0)
			error("ERROR on accept");
		pid = fork();
		if (pid < 0)
			error("ERROR on fork");
		if (pid == 0)
		{
			close(sockfd);
			sock_dostuff(newsockfd, rpc_host);
			exit(0);
		}
		else
			close(newsockfd);
	}		  /* end of while */
	return 0; /* we never get here */
}
